# Assignment-3-Code

I was successfully able to complete Project 3. The main purpose of this project is to figure out how linear, quadratic, and double hashing work and the difference between them. Also, we continue to understand how parsing files works to create a spell checker.

For Part 1 of Assignment 3, I modified and added to the create_and_test_hash file. What I did first was, in order for me to answer the questions for part 1, I needed to find a way to read the text files that were the words.txt and query_words.txt. So, I used ifsteam, which I also used in Assignment 2, to read the words and insert them into the hash table. The insert function was already given, so all I did was call it from quadratic and linear probing. h. For Part 1, it was asking to find the total number of elements in the table (N), the size of the table (T), the load factor (N/T), the total number of collisions (C), and the average number of collisions (C/N). So, what I did was I made getter functions to find these calculations. For the number of elements in the table, I returned the current_size_ variable. For the size of the table, I return the size of the array_. For the load factor, I divided the number of elements by the size of the table, which was get_load_factor that divides current_size_ by array_.size(). For the number of collisions, I made a new variable called num_collisions_ equal to 0 and inserted it into FindPos, which increments when it finds a collision. The average number of collisions was found by dividing the number of collisions by the size of the array. This part of the project was easy to do because most of the code for quadratic probing was given to us. The next part of part 1 was to check whether each word in another given file, query_words.txt, is in the hash table and print out if it was found or not found and how many probes it took to find it. I found this difficult initially because I wasn't sure how to check the number of probes. But later, I found out that to see the number of probes, I needed to add plus one to the number of collisions, in this case, to the getter, get_collisions(). The reason is that if a word is not found, there are no collisions, but there is still one probe to check. But if you find a word, you do one more than the number of collisions as probes. Lastly, I made a new file called linear_probing, where I copied everything in the quadratic probing file but deleted one line, offset+=2. Overall, part 1 was easy, besides finding the number of probes, but I was able to figure it out. An error I encountered in this section was finding the number of collisions, I forgot to set the new variable, num_collisions_, equal to 0. At first, I was confused about why I was getting incorrect outputs but later realized I forgot to make it equal to 0.

For Part 2, we were supposed to create a new file for double hashing and implement the double hashing formula. So what I did I copied and pasted the code for quadratic probing and modified it. I made a new function and variable. The function I made returns the double hashing formula: R â€“ (x mod R). R was the variable I made, and I set it equal to 89. I put it to 89 because when I test it using create_and_test_hash for double hashing, it prints out the R-value 89, which was already given to me. But I did try out numbers that were prime, like 53 and 71 but didn't end up giving me the output as the expected output given to me, which I see as an error. The part I struggled with the most was finding where to add the function for double hashing too. I played around with it and found out that it suppose to be placed in the FindPos function. So I deleted the offset+=2 from the quadratic probing that was copied earlier and edited the line with current_pos to current_pos += double_hash(x). Overall, Part 2 was tricky and took some time to think about, but I was able to get this part done 

Part 3 took me the longest to do for this assignment. In this part, I was supposed to make a spell checker by reading a document file, in this case, document1_short.txt and document1.txt, and using the dictionary for wordsEN.txt and word.txt to check if the words are spelled correctly. If it needs to be spelled correctly, find the closest word to it found in the dictionary. For me to read the files, I used ifsteam. The first time I did it after using ifstream was by making every word read in lowercase. Afterward, I made helper functions to check for punctuation, which was really important because, in the dictionary, no words have punctuation. I made a helper for punctuations at the end of the word, front of the word, front and back, and two punctuations at the end. I used these helper functions to call them in my spell checker function. This allows me to remove the punctuations at specific locations where it was found. After the punctuation of the word were removed, I used those removed punctuated words to look through the dictionary and if it is found it was correct. If not, it is incorrect. When it is incorrect or not found, I am supposed to print out 3 cases which are adding one character in any possible position(A), removing one character(B), and swapping adjacent characters of the misspelled word(C). For Case A, I made a for loop that checks the word if missing a letter and adds a letter based on the closest dictionary word found that is also one letter off. I did the same process for Cases A to B and C, where I either erased or swapped the character next to it and printed out the correct close word to the dictionary. While doing this part 3, I encountered errors. For example, for the punctuated words,  when I removed them, I just checked if the unpunctuated word was found in the dictionary or not. I forgot to check for their cases. I  noticed it midway doing part 3 while running my code, and then I fixed it. Overall, Part 3 was pretty straightforward, but it took the longest time to think about how to parse the word.

In input files are query_word.txt, document1.txt, words.txt, wordsEn.txt, document1_short.txt. These files are used for files like double_hashing, quadratic_probing, spell_check, linear_probing, quadratic_probing to read and input into.


